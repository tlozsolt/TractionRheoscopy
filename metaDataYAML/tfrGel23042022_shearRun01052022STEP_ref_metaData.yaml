# traction rheoscopy metaData template
filePaths:
  scratchDirectory_MBP: /No/longer/used
  scratchDirectory_IMAC: /Volumes/SCRATCH/tfrGel23042022/strainRamp/STEP
  scratchDirectory_SS: /mnt/serverdata/zsolt/zsolt/tfrGel23042022_shearRun01052022_strainRamp/STORAGE_SERVER_FOLDER
  scratchDirectory_ODSY: /n/holyscratch01/spaepen_lab/zsolt/mnt/serverdata/zsolt/zsolt/tfrGel23042022_shearRun01052022_strainRamp/STEP
  scratchDirectory_AWS: s3://some/path/to/debug/bucket/maybe
  testImgPath : '/Users/zsolt/Colloid/DATA/DeconvolutionTesting_Huygens_DeconvolutionLab2/OddysseyHashScripting/pyFiji/testImages'

  # projectDirectory is permanent and specific to this metaDataFile
  projectDirectory_MBP: /No/longer/used
  projectDirectory_IMAC: /Volumes/PROJECT/tfrGel23042022/strainRamp/STEP
  projectDirectory_ODSY: /n/holyscratch01/spaepen_lab/zsolt/PROJECT/tfrGel23042022/strainRamp/STEP
  tractionRheoscopyGit_ODSY: /n/home04/jzterdik/TractionRheoscopy # Hard 100 MB limit but updated with git
  tractionRheoscopyGit_MBP: /Users/zsolt/Colloid/SCRIPTS/tractionForceRheology_git/TractionRheoscopy # Hard 100 Mb limit
  tractionRheoscopyGit_IMAC: /Users/zsolt/Colloid_git/TractionRheoscopy # Hard 100 Mb limit
  TRANSFER_ODSY: /n/holylfs02/TRANSFER/jzterdik # large scale, and permanent due to special agreement with Harvard RC

  # referenceDirectory hold files that should be permanent but are too large for HOME and so must be put in SCRATCH
  # Its is possible that when $PROJECT is up and running on ODSY that these should be moved there to prevent needless
  # copying.
  calibrationDirectory_MBP: /No/longer/used
  calibrationDirectory_IMAC: /Volumes/PROJECT/calibration
  calibrationDirectory_ODSY: /n/holylfs02/TRANSFER/jzterdik/calibration
  calibrationDirectory_SS: /path/to/calibration/files/on/storage/server

  gitDirList: # files that permanent and updated/synced with git. Hard 100 Mb total git repo size limit. NO IMAGES
    - metaDataYAML
    - particleLocating
    - kilfoil_matlab
    - stressStrainAnalysis

  scratchSubDirList: # Files that are temporary and wil not generally be saved permanently
    - preprocessing
    - decon
    - postDecon
    - flatField
    - rawTiff
    - smartCrop
    - pyFiji
    - visualize

  calibrationSubDirList: # files that should be permanent, but too large for $HOME. Dont need a new folder for each run.
    - psfPath
    - darkTiff
    - ilastik

  projectSubDirList: # Files that are permanent and should be archived or a reused
    - log
    - fullStackPath
    - calibration # includes rheology, notes, piezo position
    - locations
    - dplPath # note that files written to dplPath are **all** the script files,
              # which also have hard coded extensions such as "extension='_preprocessing.ijm'
              # not the default extensions read from the yaml file as is the case for all other directories
  #
  # calibration data
  gelRheology: /path/to/gel/rheology/on/stoargeServer/
  experimentTable: /path/to/table/of/shearParameters/
  piezoPath: /path/to/piezo/motion/output/and/control/files/
  fullStackPath: /path/to/full/zStacks/to/determine/absolute/gel/and/sediment/and/grid/locations/
  notesPath: /path/to/notes/during/image/acquisition/
  #
  # software paths
  #dplPath_MBP: /Users/zsolt/Colloid/SCRIPTS/tractionForceRheology_git/TractionForceRheology/particleLocating
  fijiPath_MBP: /Applications/Fiji.app/Contents/MacOS/ImageJ-macosx # note this is an executable
  fijiPath_IMAC: /Applications/Fiji.app/Contents/MacOS/ImageJ-macosx # note this is an executable
  fijiPath_ODSY: /n/home04/jzterdik/SOFTWARE/Fiji.app/ImageJ-linux64 # Check that the fast FFT and Mosaic libraries are also installed

  matlabPath_ODSY: /path/to/MATLAB/if/not/standard/modulue/
  matlabPath_MBP: /Applications/MATLAB_R2018b.app/bin/matlab
  matlabPath_IMAC: /Applications/MATLAB_R2018b.app/bin/matlab

  DL2Path_ODSY: /n/home04/jzterdik/SOFTWARE/Fiji.app/plugins
  DL2Path_MBP: /Applications/Fiji.app/plugins
  DL2Path_IMAC: /Applications/Fiji.app/plugins

  javaPath_MBP: java
  javaPath_IMAC: java
  javaPath_ODSY: module load Java/1.8

  loadPython_ODSY: module load Anaconda3/5.0.1-fasrc02
  loadMatlab_ODSY: module load matlab/R2018b-fasrc01
  loadIlastik_ODSY: module load ilastik/1.3.2-fasrc01

  #ilastik_ODSY: /n/helmod/apps/centos7/Core/ilastik/1.3.2-fasrc01/run_ilastik.sh # not sure if this is the correct call
  ilastik_ODSY: /n/home04/jzterdik/SOFTWARE/ilastik-1.4.0b14-Linux/run_ilastik.sh
  ilastik_IMAC: /Applications/ilastik-1.4.0b13-OSX.app/Contents/ilastik-release/run_ilastik.sh
################
fileNamePrefix:
  global: tfrGel23042022_shearRun01052022STEP_
  refBool: True
  preprocessing: preProcess_
  decon: decon_
  postDecon: postDecon8Bit_
  locations: locations_
  flatField: flatField_
  smartCrop: smartCrop_
  ilastik: ilastik_
  metaDataYAML: metaData
  log: log_
  # tfrGel23042022_shearRun01052022_f_imageStack_t000097_z0471.tif
  rawTiff: tfrGel23042022_shearRun01052022STEP_ # may not be necessary as I only read from the raw directory and never write to it.
  tPadding: 6
  zPadding: 4
  dplPath: dplScript_
  darkTiff: darkImage_NoBinning_CameraZylaSideRFP  # does not have global fileNamePrefix
  psfTiffRegExp: 'psf_dim400_400_150_absZ*.tif' # Will depdend on bining
  visualize:
    raw: raw_
    decon: decon_
    flatField: flatField_
    glyph: glyph_
    locating_input : locating_input_
############
fileExtensions:
   preprocessing: .tif
   hash: .yaml
   log: .yaml
   decon: .tif
   postDecon: .tif
   flatField: .tif
   rawTiff: .tif
   metaDataYAML: .yaml
   psfPath: .tif
   darkTiff: .tif
   fullStackPath: .tif
   calibration: .text # includes rheology, notes, piezo position, its not clear that all the files will have this extension.
   dplPath: .x
   smartCrop: .tif
   pyFiji: .tif
   ilastik: .hdf
#######
imageParam:
  stackBool: False
  xDim: 2048 # full image dimension in x direction, units of pixels
  yDim: 2048 # ...and in in y
  zDim: 1555 # number of z -slices
  timeSteps: 1 # total number of number of time steps
  shearTime: [NAN, NAN] # shear start and stop timesteps assuming zero indexing
  px2Micron: {'x': 0.115, 'y': 0.115, 'z': 0.15} # list of multiplicative factors, this should be changed to just report raw and handle any upscaling when/if that happens during the pipleine
  #px2Micron_raw: {'x': 0.230, 'y': 0.230, 'z': 0.15} # list of multiplicative factors to convert px to micron in xyz
  stackTime: NAN # time to acquire a stack in seconds
  stackInterval: NAN # time between successive stacks, note: stackInterval > stackTime
  gelSedimentLocation: 956 # location in z of gel/sediment transition in imaging stack. If tilted, report height to give thickest gel
  interfaceRange: [950,956]
  shearPostLocation: 1522 # location in z of shearpost in imaging stack. If tilted, report height as rough average.
  gelSedimentLocation_fullStack: 951 # location of gel/sediment transition in full stack image, not imaging stack
  reference2ImageStack: [951,219]
  coverSlipReferenceStack: 21
  piezoPos: # position of the objective piezo as read off optical encoder at various locations
    imageStackBottom: 150
    imageStackTop: NAN
    coverslip: 0
    gelSediment: NAN
#######
#######
shearParam:
  exptIntention: strain sweep to locate yield point # shear processing to crystallize, oscillatory rheology at freq, etc
  waveform: ref # triangle, triangle wave, sine, ...
  velocity: NAN # velocity of plate in microns per second
  a: NAN # step size, typical target is two steps per second given serial bandwidth
  oscillations: 1 # number of repeated oscillations
#######
#######
pipeline: # note that this is an **ordered** list of step (ie dict keywords) and boolean values except that start
  - hash: True # maybe we dont need a rawTiff "step" Not clear. We do need to know where the rawTiff files are stored
  - rawTiff: True # Everything starts with the microscope image, but this could be False if analysis has been restarted
  - preprocessing: False
  - flatField: True
  - decon: True
  - smartCrop: True
  - postDecon: True
  - locating: True
  - tracking: False

hash:
  software: python
  crop: True
  dimensions:
    gel:
      xyz: [450,450,200] # XYZ dimensions of the hash
      minOverlap: [50,50,50] # minimum overlap in XYZ
      pxOverlap_w_sed: 50 # how much overlap in pixels should gel chunks have with sediment? \
                          # This defines the upper bound for hashing gel chunks
    sed:
      xyz: [450,450,200]
      minOverlap: [50,50,50]
      pxOverlap_w_gel: 70 # how much overlpa should sed chunks have with gel?
                          # This is height below gelSedimentLocation
                          # and defines the lower bound for hashing sed chunks
preprocessing:
  software: ImageJ
  crop: False # does this step do any cropping on top of the initial hash?
  bkSubtractBool: True # is the background subtracted prior to deconvolution?
  bkSubtractMethod: gaussian # method names, rbFilter, gaussian
  params:
    width: 40 # width of gaussian in pixels
    32BitFloat: True
    16BitConv: True

flatField:
  software: python
  crop: False # This flag is whether there is additional cropping to hash for logging purposes. "False" is a bit misleading because the images are first actually cropped according to hash parameters in Flatfield, but there is no cropping in addition to the hash.
  crop2Hash: True # this controls whether the images are cropped in flatField
  returnType: uint16 # after flatfielding what the is the data type of a single pixel? unit16 in "unisgned 16 bit integer"
  flatStack_method: gaussianBlur # description of how the the flatStack is formed. Either a guassian blur or an actual microscope image of an optical phantom
  sigma: 15 # standard deviation of gaussian used
  dim: 3D # slice by slice in 2D or full 3D?
  darkFrame_method: darkStackAvg
  masterDark: '/darkTiff/masterDark_zyla2923_60msExp_15kFrames.tif'

decon:
  software: DeconvolutionLab2 # string saying what software was used to carry out decon
  crop: False # does this step do any cropping on top of the initial hash?
  method: RLTV # string specifying deconvolution method, probably Richardson-Lucy with Total Variation Regularization
  iterations: 30 # number of iterations for deconvolution
  lambda:
    sed: 0.000000001 # regularization parameter, default. will vary next line during debugging
    #sed: 0.0000001 # regularization parameter
    gel: 0.001
  psf_info: theorectical generated by Huygens
  path2PSF: see filePaths
  garbageSlices: 2 # number of z-slices to discard after deconvolution
  apodization:
    bool: True
    lateral: 'NO'
    axial: 'NO'
  padding:
    bool: True
    lateral: E2
    axial: E2

ilastik:
    bool: True
    crop: False # does this step do any cropping? No. All cropping will be handled in smartCrop which takes, as inputs, both ilastik and decon outputs
    type: pxClassifier # what ilastik classfier to use, probably always pxClassifier but inprinciple could be coded for something else
    pxClassifier:
      run_args:
        headless: True
        readonly: True
        export_source: Probabilities
        output_format: hdf5
        output_filename_format: '{dataset_dir}/{nickname}_probabilities.h5'
      #classfier_subPath: '/Volumes/TFR/tfrGel10212018A_shearRun10292018f/interfaceLocating/pixelClassification_multiLaneTraining/tfrGel09052019a_shearRun10292018f_pxClassifier.ilp' # This needs to be updated to place the ilastik file in the calibration directory
      #classifier_fName: 'tfrGel09052019a_shearRun10292018f_pxClassifier.ilp'
      #classifier_fName: 'tfrGel09052019a_shearRun10292018f_pxClassifier_w_gridTraining_nonFluorChunk.ilp'
      #classifier_fName: 'tfrGel23042022_shearRun23042022_imageStack_21MAY2022.ilp'
      classifier_fName: 'tfrGel23042022_shearRun23042022_imageStack_16JUN2022.ilp'
      channels: # list of the channels and what they label
        gel_Background: 0
        gel_Tracer: 1
        sed_Colloid: 2
        sed_Background: 3
        fluorescent_chunk: 4
        nonfluorescent_chunk: 5
      sedGelSplit:
        weights:
          sed: [0,0,1,1,1,0]
          gel: [1,1,0,0,0,0]
          chunk: [0,0,0,0,1,1]
        cutoff:
          gel: 0.5
          sed: 0.5
          chunk: 0.5

smartCrop:
  software: python
  crop: True
  daskBool: False
  ilastik: True # use ilastik?
  fftCrop: # Crop just to get rid of garbage due to periodic boundary conditions on FFT
    bool: True
    X: 10
    Y: 10
    Z: 17
  sedGelCrop: # additional axial trimming to get rid of sediment slices from gel stack or gel slices from sediment for maxEnt histogram thresholding.
    bool: True
    method: zGradAvgXY
    offset: 4 # number of z-slices above(+) or below(-) relative to the index position of max value
    minValue: 2000 # smallest value of gradient to ensure that you have found a true peak
    maxDev: 45 # sedGel position found using this method must be within maxDev from value listed in imageParam: gelSedimentLocation

postDeconCombined:
  cleanup: True
  locInput: False
  bool: True
  dask: True
  steps: # ordered list of steps
    - smartCrop
    - threshold
    - postThresholdFilter
    - upscale
    - locate
    - refine
    - visualize
postDecon:
  software: python
  crop: False # How many pixels to trim off the image borders?
  output:
    dtype: uint8 # what format should the image be returned?
    recastBool: True # should histogram be stretched over dtype range at the end?
  upScaling:
    bool: False
    postThreshold: True
    software: python
    dim: {x: 2,y: 2} # z upscaling is not supported
    interp_method: lanczos # open_cv options include linear, cubic, bicubic, lanczos.
    parallel:
      bool: True
      n_jobs: 4
  threshold:
    bool: True
    local: # python only
      bool: True
      blockDim:
        X: 150 #was 250 as a standard choice
        Y: 150
        Z: 50
      sample: # number of samples at which to compute local thresholding
        n_xyz : [5,5,4] # this will be a list
        #n_xyz : [3,3,4] # this will be a list, used for 250,250,50 chunks
      parallel:
        bool: True
        n_jobs: 8
      dask:
        #rechunk_nzyx: [4,5,5]
        rechunk_nzyx:
            sed: [7,15,15]
            gel : [4,5,5]
        depth_delta: -10 # how much smaller to make depth than the chunk size?
        boundary: reflect
    method:
      gel: MaxEnt
      sed: MaxEnt
    scaleFactor:
      gel: 0.3
      sed: 1.0
    range: no-reset # in pricnple both imageJ and python
  postThresholdFilter: # if imageJ, use mosaic parameters
    gel:
      bool: True
      methodParamList: # ordered list of dictionaries containing parameters
        #- { method: meanCurvature, iter: 10, n_jobs: 4}
        #- { method: gaussianBlur, sigma: 2, n_jobs: 4}
        #- {method: totalVariation, iter: 25, n_jobs: 4}
        - { method: gaussianBlur, sigma: 2, n_jobs: 4}
    sed:
      bool: True
      methodParamList: # ordered list of dictionaries containing filter method and parameters
        - { method: totalVariation, iter: 5, n_jobs: 4}
        - { method: gaussianBlur, sigma: 1, n_jobs: 4}
        #- {method: equalize_adapthist, clip_limit: 0.03, n_jobs: 4}
        #- { method: meanCurvature, iter: 3, n_jobs: 4}
        #- { method: guassianBlur, sigma: 1}

    mosaic: # Image-J only, although similar filters have been written in python as well.
      bool: False
      gaussianCurvature:
        bool: True
        filter_name: Gausian Curvature 3D # Yes, Gaussian is misspelled
        iter: 50
      meanCurvature2D:
        bool: True
        filter_name: "[MC (Mean Curvature)]"
        method: "[No split]"
        iter: 3
#######
#######
locating_matlab:
  crop: False
  locatingScriptPath: /path/to/matlab/locating/and/submission/scripts/used/
  matlabVariable: [] # list of key:value pairs for all the variables matlab needs to run
  bandPassBool: False # does the locating code cary out a band pass filter for any reason?
  deconvolvedBool: True # is the image deconvolved prior to locating?
  iterBool: True # use iterative locating?
  sedimentParam: # list of particle locations for locating the sediment
    # Note that object size will depend **strongly** on the type of thresholding done in postDecon.
    # MaxEnt will give small particles (typically 2-3 pixels in xy and a few more in z, while Default will give
    # closer to actual size of [4,4,11] px
    outputSuffix: _sed
    lnoise: [0.9, 0.9, 0.7] # I dont actually think this is used since the images wont be bandpass filtered
    lobject: [27, 27, 27] # Only used if image is bandpass filtered
    diameters: [5, 5, 13] # somewhat larger than feature size
    mask_size: [3, 3, 7] # somewhat smaller than feature size
    min_separation: [3, 3, 5] # merge two local maxima if within this distance. Set equal to smaller than core size
    masscut_initial: 0 # initial mass cut
    masscut_residuals: 1000 # mass cut during interative locativing
    false_particle_size: [7, 7, 13] # for core shell this should be somewhat smaller than
                                      # 2*(nearest neighbor distance)- (core diameter)
    bridgeThreshold: 0.5 # i dont think this is used either
    zeroPxThreshold: 200 # max overlap with zero pixels
  gelParam: #list of particle location values used for locating the gel particles
    outputSuffix: _gel
    lnoise: [0.9, 0.9, 0.7] # I dont actually think this is used since the images wont be bandpass filtered
    lobject: [27, 27, 27]
    diameters: [31, 31, 15]
    mask_size: [23, 23, 9]
    min_separation: [7, 7, 7] # These should comparitively large relative to the diameters since the gel is sparse.
    masscut_initial: 20000 # initial mass cut
    masscut_residuals: 30000 # mass cut during interative locativing
    false_particle_size: [27, 27, 13]
    bridgeThreshold: 0.5 # i dont think this is used either
    zeroPxThreshold: 500 # mobject: [27, 27, 29]

locating:
  software: python
  crop: False
  visualize: True
  pxClassifier:
    bool: True # should I compute integrals of the pxClassifier around the located particle positions
    integrate_mask: # must be converted to nonmutable type tuple after loading, also this is a radius
      gel: [3.5,4.6,4.6] # radius in pixels zyx to integrate over
      sed:
        core: [1.5, 2.5, 2.5]
        shell: [3.0, 5.0, 5.0]

  iterative:
    bool: True # do iterative locating?
    maxIter: 7 # how many iterative locating loops to do before force quitting? Note this is *not* the same as how iterations of refinement to do, but rather how many iterations of iterative locating to do.
    mask:
      sed: [[16, 20, 20]] # If you want fixed size, put in a nested list of len 1, eg [[17,17,17]], otherwise iterations will step through list and adjust mask size. May 2022
      gel: [[21,27,27]] # pixel order is [z,y,x] keep in mind this can be much larger than a single particle diameter
  refine_lsq:
    bool: True
    refine_array: None
    compute_error: True
    func:
      sed: disc
      gel: disc
  sed: # ordered list of dictionary parameter values for first iterations. If only two, then treat as initial and all subsequent parameters
    - { diameter: [15, 17, 17], separation: [11,11,11], minmass: 5.0e+5, preprocess: False, max_iterations: 30, refine_lsq: { disc: {fit_function: 'disc', diameter: [15,17, 17], max_iter: 65, max_shift: 0.05, max_rms_dev: 0.2, param_val: {disc_size: 0.21, size_x: 4.0, size_y : 4.0, size_z: 3.88}, compute_error: True}}}
    #- {diameter: [15,17,17], separation:[11,11,11], minmass: 6.0e+5, preprocess: False, max_iterations: 30, refine_lsq: { disc: {fit_function: 'disc', diameter: [15,17, 17], max_iter: 65, max_shift: 0.05, max_rms_dev: 0.2, param_mode: {background: 'var',disc_size: 'var', size_z: 'var', size_x: 'var', size_y: 'var'}, bounds: {'disc_size': [0.2,0.8], size_x:[2,7], size_y: [2,7], size_z: [1,5]}, param_val: {disc_size: 0.2, size_x: 3.5, size_y: 3.5, size_z: 2.05, background: 0 }, compute_error: True}}}
    #- { diameter: [11, 11, 11], separation: [11,11,11], minmass: 4.0e+6, preprocess: False, max_iterations: 30, refine_lsq: { disc: {fit_function: 'disc', diameter: [9,11, 11], max_iter: 35, max_shift: 0.1, max_rms_dev: 0.5, param_val: {disc_size: 0.2, size_x: 3.4, size_y : 3.4, size_z: 2}, compute_error: True}}}
    #- { diameter: [15, 15, 15], separation: [11,11,11], minmass: 2.0e+6, preprocess: False, max_iterations: 30, refine_lsq: { disc: {fit_function: 'disc', diameter: [9,11, 11], max_iter: 35, max_shift: 0.1, max_rms_dev: 0.5, param_val: {disc_size: 0.2, size_x: 3.4, size_y : 3.4, size_z: 2}, compute_error: True}}}
    #- { diameter: [15, 15, 15], separation: [11,11,11], minmass: 6.0e+5, preprocess: False, max_iterations: 30, refine_lsq: { disc: {fit_function: 'disc', diameter: [9,11, 11], max_iter: 35, max_shift: 0.1, max_rms_dev: 0.5, param_val: {disc_size: 0.2, size_x: 3.4, size_y : 3.4, size_z: 2}, compute_error: True}}}
    #- { diameter: [15, 15, 15], separation: [11,11,11], minmass: 6.0e+5, preprocess: False, max_iterations: 30, refine_lsq: { disc: {fit_function: 'disc', diameter: [9,11, 11], max_iter: 35, max_shift: 0.1, max_rms_dev: 0.5, param_val: {disc_size: 0.2, size_x: 3.4, size_y : 3.4, size_z: 2}, compute_error: True}}}
    #- { diameter: [15, 15, 15], separation: [11,11,11], minmass: 1.0e+5, preprocess: False, max_iterations: 30, refine_lsq: { disc: {fit_function: 'disc', diameter: [9,11, 11], max_iter: 35, max_shift: 0.1, max_rms_dev: 0.5, param_val: {disc_size: 0.2, size_x: 3.4, size_y : 3.4, size_z: 2}, compute_error: True}}}
    #- { diameter: [15, 15, 15], minmass: 9000, preprocess: False, max_iterations: 30, separation: [11,11,11], percentile: 0.9, refine_lsq: { gauss: {max_iter: 25, fit_function: 'gauss', diameter: [9, 9, 9], max_shift: 0.1, max_rms_dev: 0.01, compute_error: True}}}
    #- { diameter: [15, 15, 15], minmass: 9000, preprocess: False, max_iterations: 20, separation: [11,11,11], percentile: 0.9, refine_lsq: { gauss: {max_iter: 25, fit_function: 'gauss', diameter: [13, 13, 13], compute_error: True}}}
    #- { diameter: [15, 15, 15], minmass: 9000, preprocess: False, max_iterations: 20, separation: [11,11,11], percentile: 0.9, refine_lsq: { gauss: {max_iter: 25, fit_function: 'gauss', diameter: [13, 13, 13], compute_error: True}}}
    #- { diameter: [15, 15, 15], minmass: 9000, preprocess: False, max_iterations: 20, separation: [ 9, 9, 9], percentile: 0.9, refine_lsq: { gauss: {max_iter: 25, fit_function: 'gauss', diameter: [13, 13, 13], compute_error: True}}}
  gel:
    #- {diameter: [21,25,25], minmass: 9000000, preprocess: False, max_iterations: 30, refine_lsq: { disc: {fit_function: 'disc', diameter: [16,21, 21], max_iter: 65, max_shift: 0.05, max_rms_dev: 0.2, param_mode: {background: 'var',disc_size: 'var', size_z: 'var', size_x: 'var', size_y: 'var'}, bounds: {'disc_size': [0.2,0.8], size_x:[6,12], size_y: [6,12], size_z: [4,11]}, param_val: {disc_size: 0.42, size_x: 9.5, size_y: 9.5, size_z: 7.05, background: 0 }, compute_error: True}}}
    - {diameter: [21,25,25], minmass: 6.0e+6, preprocess: False, max_iterations: 30, refine_lsq: { disc: {fit_function: 'disc', diameter: [16,21, 21], max_iter: 65, max_rms_dev: 0.2, param_mode: { background: 'var', disc_size: 'var', size_z: 'var', size_x: 'var', size_y: 'var'}, bounds: {'disc_size': [0.2,0.8], size_x: [6,12], size_y: [6,12], size_z: [4,11]}, param_val: {disc_size: 0.42, size_x: 9.5, size_y: 9.5, size_z: 7.05, background: 0 }, compute_error: True}}}
dask_resources:
  IMAC:
    #ip: '10.0.0.33:8786'
    ip: 'auto'
    nprocs: 8
    nthreads: 8
    memory-limit: '4Gb'
    local_directory: '/Users/zsolt/dask_scratch'
  ODSY:
    ip: 'auto'
    nprocs: 4 # number of processes can be 2x the number of cores to boost utilization if memory is not constrained.
    nthreads: 1
    local_directory: '/scratch'
    memory-limit: '32Gb'
ODSY_Resources:
  queue: serial_requeue
  time: 0-16:00 # requested time in units of minutes
  cores: 4 # number of requested cores
  nodes: 1 # this is important for dask, to force all cores to be on the same node
  mem: 32000 # memory pool for all cores in units of Mb
  account: weitz_lab

paintByLocations:
  units: pixels
  program: trackpy
  locColumns: ['z','y','x']
  sep: ' '
  sed:
    dim: [15,15,15]
    boxDim: [17,17,17]
  gel:
    dim: [21,21,21]
    boxDim: [23,23,23]

data_analysis:
  # any analysis of the particles *after* particle locating.
  grid:
    signature: '[[t,z1,y1,x1],[1.z2,y2,x2]]'
    coordStr: '(px, imageCoord)'
    comment: >
      lines are specfified by pair of points (t,z,y,x) in pixels
      on the raw image
    lines:
      - {t :  0, z0 : 572, y0 :    0, x0 :  538, z1 : 558, y1 : 2046, x1 : 1638}
      - {t :  0, z0 : 560, y0 : 1278, x0 :   46, z1 : 567, y1 :  208, x1 : 2008}
      - {t :  0, z0 : 562, y0 : 1481, x0 : 2026, z1 : 558, y1 : 2028, x1 : 1026}
      - {t :  0, z0 : 561, y0 : 1336, x0 :    8, z1 : 556, y1 : 2040, x1 : 356}
      - {t : 40, z0 : 563, y0 :   46, x0 :  625, z1 : 550, y1 : 2028, x1 : 1700}
      - {t : 40, z0 : 559, y0 :  232, x0 : 2001, z1 : 556, y1 : 1304, x1 : 76}
      - {t : 40, z0 : 555, y0 : 1524, x0 : 2034, z1 : 551, y1 : 2034, x1 : 1054}
      - {t : 40, z0 : 555, y0 : 1226, x0 :   16, z1 : 550, y1 : 2028, x1 : 425}
      - {t : 85, z0 : 566, y0 :   25, x0 :  568, z1 : 554, y1 : 2026, x1 : 1628}
      - {t : 85, z0 : 564, y0 :  232, x0 : 1934, z1 : 559, y1 : 1285, x1 : 49}
      - {t : 85, z0 : 558, y0 : 1485, x0 : 2045, z1 : 554, y1 : 2045, x1 : 1001}
      - {t : 85, z0 : 557, y0 : 1384, x0 :   28, z1 : 553, y1 : 2036, x1 : 358}
    tracer: {t: 0, x: 869, y: 554 , z: 566 }
  rotation:
    description: >
      This is rotation matrix to rotate image coordinates in rheo_sedHeight coordinate
      system to coordinates in which the shear direction is along the x direction
      The coordinate system it assumes is listed under the key coordStr
      If it is rheo_sedHeight, this coordinate system is just a reflection
      of the y-axis from the image coordinate system so that it is right handed
      (ie right handed with z point up into the sample and x to the right, where as the image coordinate
      system is the array indexing with x being the fasted index, y pointing down, and z going up into the
      sample.)
    tracer:
      description: >
        This is the manual tracking of a particle clearly on the TEM grid over a few time points
      coordStr: (um, imageCoord)
      position:
        - []
        - []
      time_list:
        - [0,10,30,40,50,60,70]
    rotationMatrix:
      coordStr: (um, rheo_sedHeight)
      handed: right
      positiveSignature: clockwise
      units: degrees
      theta_x: 0 # rotation angle about x-axis
      theta_y: 0 # rotation angle about y-axis
      theta_z: 1.3 # rotation angle about z-axis
