# traction rheoscopy metaData template
filePaths:
  scratchDirectory_MBP: /Users/zsolt/Colloid/DATA/DeconvolutionTesting_Huygens_DeconvolutionLab2/OddysseyHashScripting
  scratchDirectory_SS: /path/to/working/directory/specific/to/this/metaData/file
  scratchDirectory_ODSY: /n/holyscratch01/spaepen_lab/dpl_test # intermediate storage, no long term backup. Folder for each run

  # projectDirectory is permanent and specific to this metaDataFile
  projectDirectory_MBP: /Users/zsolt/Colloid/DATA/DeconvolutionTesting_Huygens_DeconvolutionLab2/OddysseyHashScripting
  projectDirectory_ODSY: /n/home04/jzterdik/DATA
  tractionRheoscopyGit_ODSY: /n/home04/jzterdik/TractionRheoscopy # Hard 100 MB limit but updated with git
  tractionRheoscopyGit_MBP: /Users/zsolt/Colloid/SCRIPTS/tractionForceRheology_git/TractionRheoscopy # Hard 100 Mb limit

  gitDirList: # files that permanent and updated/synced with git. Hard 100 Mb total git repo size limit. NO IMAGES
    - metaDataYAML
    - particleLocating
    - kilfoil_matlab
    - stressStrainAnalysis

  scratchSubDirList: # Files that are temporary and wil not generally be saved permanently
    - preprocessing
    - decon
    - postDecon
    - flatField
    - rawTiff
    - smartCrop

  projectSubDirList: # Files that are permanent and should be archived or a reused
    - log
    - psfPath
    - darkTiff
    - fullStackPath
    - calibration # includes rheology, notes, piezo position
    - locations
    - dplPath # note that files written to dplPath are **all** the script files,
              # which also have hard coded extensions such as "extension='_preprocessing.ijm'
              # not the default extensions read from the yaml file as is the case for all other directories
  # 
  # calibration data
  gelRheology: /path/to/gel/rheology/on/stoargeServer/
  experimentTable: /path/to/table/of/shearParameters/
  piezoPath: /path/to/piezo/motion/output/and/control/files/
  fullStackPath: /path/to/full/zStacks/to/determine/absolute/gel/and/sediment/and/grid/locations/
  notesPath: /path/to/notes/during/image/acquisition/
  #
  # software paths
  #dplPath_MBP: /Users/zsolt/Colloid/SCRIPTS/tractionForceRheology_git/TractionForceRheology/particleLocating
  fijiPath_MBP: /Applications/Fiji.app/Contents/MacOS/ImageJ-macosx # note this is an executable
  fijiPath_ODSY: /n/home04/jzterdik/SOFTWARE/Fiji.app/ImageJ-linux64 # Check that the fast FFT and Mosaic libraries are also installed

  matlabPath_ODSY: /path/to/MATLAB/if/not/standard/modulue/
  matlabPath_MBP: /Applications/MATLAB_R2018b.app/bin/matlab

  DL2Path_ODSY: /n/home04/jzterdik/SOFTWARE/Fiji.app/plugins
  DL2Path_MBP: /Applications/Fiji.app/plugins

  javaPath_MBP: java
  javaPath_ODSY: module load Java/1.8

  loadPython_ODSY: module load Anaconda3/5.0.1-fasrc02
  loadMatlab_ODSY: module load matlab/R2018b-fasrc01
################
fileNamePrefix:
  global: tfrGel09052019b_shearRun05062019i_
  preprocessing: preProcess_
  decon: decon_
  postDecon: postDecon8Bit_
  locations: locations_
  flatField: flatField_
  smartCrop: smartCrop_
  metaDataYAML: metaData_scriptTesting
  log: log_
  rawTiff: tfrGel09052019b_shearRun05062019i_ # may not be necessary as I only read from the raw directory and never write to it.
  dplPath: dplScript_
  darkTiff: darkImage_65ms_camera2922_zStack # does not have global fileNamePrefix
############
fileExtensions:
   preprocessing: .tif
   hash: .yaml
   log: .yaml
   decon: .tif
   postDecon: .tif
   flatField: .tif
   rawTiff: .tif
   metaDataYAML: .yaml
   psfPath: .tif
   darkTiff: .tif
   fullStackPath: .tif
   calibration: .text # includes rheology, notes, piezo position, its not clear that all the files will have this extension.
   dplPath: .x
   smartCrop: .tif
#######
imageParam:
  xDim: 1024 # full image dimension in x direction, units of pixels
  yDim: 1024 # ...and in in y
  zDim: 597 # number of z -slices
  timeSteps: 1 # total number of number of time steps
  shearTime: [1, 226] # shear start and stop timesteps assuming zero indexing
  px2Micron: [0.230, 0.230, 0.15] # list of multiplicative factors to convert px to micron
  stackTime: 176 # time to acquire a stack in seconds
  stackInterval: 180 # time between successive stacks, note: stackInterval > stackTime
  gelSedimentLocation: 202 # location in z of gel/sediment transition in imaging stack. If tilted, report height to give thickest gel
  gelSedimentLocation_fullStack: 0 # location of gel/sediment transition in full stack image, not imaging stack
  piezoPos: # position of the objective piezo as read off optical encoder at various locations
    imageStackBottom: 220 
    imageStackTop: 350
    coverslip: 100
    gelSediment: 245
#######
#######
shearParam:
  exptIntention: strain sweep to locate yield point # shear processing to crystallize, oscillatory rheology at freq, etc
  waveform: triangle # triangle, triangle wave, sine, ...
  velocity: 0.00000 # velocity of plate in microns per second
  a: 0.000000 # step size, typical target is two steps per second given serial bandwidth 
  oscillations: 1 # number of repeated oscillations 
#######
#######
pipeline: # note that this is an **ordered** list of step (ie dict keywords) and boolean values except that start
  - hash: True # maybe we dont need a rawTiff "step" Not clear. We do need to know where the rawTiff files are stored
  - rawTiff: True # Everything starts with the microscope image, but this could be False if analysis has been restarted
  - preprocessing: False
  - flatField: True
  - decon: True
  - smartCrop: True
  - postDecon: True
  - locating: True
  - tracking: False
hash:
  software: python
  crop: True
  dimensions:
    gel:
      xyz: [256,256,110] # XYZ dimensions of the hash
      minOverlap: [30,30,30] # minimum overlap in XYZ
    sed:
      xyz: [256,256,110]
      minOverlap: [30,30,30]

preprocessing:
  software: ImageJ
  crop: False # does this step do any cropping on top of the initial hash?
  bkSubtractBool: True # is the background subtracted prior to deconvolution?
  bkSubtractMethod: gaussian # method names, rbFilter, gaussian
  params:
    width: 40 # width of gaussian in pixels
    32BitFloat: True
    16BitConv: True

flatField:
  software: python
  crop: False # This is a bit misleading because the images are first actually cropped according to hash parameters in Flatfield, but there is no cropping in addition to the hash.
  crop2Hash: True
  returnType: uint16 # after flatfielding what the is the data type of a single pixel? unit16 in "unisgned 16 bit integer"
  flatStack_method: gaussianBlur # description of how the the flatStack is formed. Either a guassian blur or an actual microscope image of an optical phantom
  sigma: 15 # standard deviation of gaussian used
  dim: 3D # slice by slice in 2D or full 3D?
  darkFrame_method: darkStackAvg

decon:
  software: DeconvolutionLab2 # string saying what software was used to carry out decon
  crop: False # does this step do any cropping on top of the initial hash?
  method: RLTV # string specifying deconvolution method, probably Richardson-Lucy with Total Variation Regularization
  iterations: 30 # number of iterations for deconvolution
  lambda: 0.000001 # regularization parameter
  psf_info: theorectical generated by Huygens
  path2PSF: see filePaths
  garbageSlices: 2 # number of z-slices to discard after deconvolution
  apodization:
    bool: True
    lateral: 'NO'
    axial: 'NO'
  padding:
    bool: True
    lateral: E2
    axial: E2

smartCrop:
  crop: True
  fftCrop: # Crop just to get rid of garbage due to periodic boundary conditions on FFT
    bool: True
    X: 10
    Y: 10
    Z: 17
  sedGelCrop: # additional axial trimming to get rid of sediment slices from gel stack or gel slices from sediment for maxEnt histogram thresholding.
    bool: True
    method: zGradAvgXY
    offset: 4 # number of z-slices above(+) or below(-) relative to the index position of max value
    minValue: 2000 # smallest value of gradient to ensure that you have found a true peak
    maxDev: 10 # sedGel position found using this method must be within maxDev from value listed in imageParam: gelSedimentLocation

postDecon:
  software: ImageJ
  crop: False # How many pixels to trim off the image borders?
  threshold:
    bool: True
    method:
      gel: MaxEnt
      sed: Default
    background: dark
    range: no-reset
  mosaic:
    bool: True
    gaussianCurvature:
      bool: True
      filter_name: Gausian Curvature 3D # Yes, Guassian is misspelled
      iter: 50
    meanCurvature2D:
      bool: True
      filter_name: "[MC (Mean Curvature)]"
      method: "[No split]"
      iter: 3
  outputType: uint8
#######
#######
locating:
  crop: False
  locatingScriptPath: /path/to/matlab/locating/and/submission/scripts/used/
  matlabVariable: [] # list of key:value pairs for all the variables matlab needs to run
  bandPassBool: False # does the locating code cary out a band pass filter for any reason? 
  deconvolvedBool: True # is the image deconvolved prior to locating?
  iterBool: True # use iterative locating?
  sedimentParam: # list of particle locations for locating the sediment
    # Note that object size will depend **strongly** on the type of thresholding done in postDecon.
    # MaxEnt will give small particles (typically 2-3 pixels in xy and a few more in z, while Default will give
    # closer to actual size of [4,4,11] px
    outputSuffix: _sed 
    lnoise: [0.9, 0.9, 0.7] # I dont actually think this is used since the images wont be bandpass filtered
    lobject: [27, 27, 27] # Only used if image is bandpass filtered
    diameters: [5, 5, 13] # somewhat larger than feature size
    mask_size: [3, 3, 7] # somewhat smaller than feature size
    min_separation: [3, 3, 5] # merge two local maxima if within this distance. Set equal to smaller than core size
    masscut_initial: 0 # initial mass cut
    masscut_residuals: 1000 # mass cut during interative locativing
    false_particle_size: [7, 7, 13] # for core shell this should be somewhat smaller than
                                      # 2*(nearest neighbor distance)- (core diameter)
    bridgeThreshold: 0.5 # i dont think this is used either
    zeroPxThreshold: 200 # max overlap with zero pixels
  gelParam: #list of particle location values used for locating the gel particles
    outputSuffix: _gel 
    lnoise: [0.9, 0.9, 0.7] # I dont actually think this is used since the images wont be bandpass filtered
    lobject: [27, 27, 27]
    diameters: [10, 10, 26]
    mask_size: [5, 5, 15]
    min_separation: [5, 5, 15] # These should comparitively large relative to the diameters since the gel is sparse.
    masscut_initial: 0 # initial mass cut
    masscut_residuals: 3000000 # mass cut during interative locativing
    false_particle_size: [13, 13, 27]
    bridgeThreshold: 0.5 # i dont think this is used either
    zeroPxThreshold: 200 # mobject: [27, 27, 29]
ODSY_Resources:
  queue: serial_requeue 
  time: 360 # requested time in units of minutes
  cores: 1 # number of requested cores
  mem: 16000 # memory pool for all cores in units of Mb
